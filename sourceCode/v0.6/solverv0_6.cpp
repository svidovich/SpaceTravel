#include <iostream>
#include <Eigen/Dense>
#include <math.h>
#include <fstream>
#include <string>
#include <cstdlib>
#include "hires_timer-1.c"
#include "functions.h"
#include "robsmath.h"
#include <vector>
const double pi = 3.1415926536;
using namespace Eigen;
using namespace std;


// Solver function. Perhaps there's a better way of doing this, but who cares?
void solver(Matrix3d& F, Matrix3d& P, Matrix3d& J, Matrix3d& Q, Vector3d& p, Vector3d& x, double h, double m, double tol, int n);

ofstream fout, xout; // These are global, be careful.

int main()
{
	/* Initializations Begin here */

	int i;
	double ts, tf, h, m, error; // Timer Start | Timer Finish | Resolution | Mass | Error of Calculation
	int n;
	double tol = 0.0001; // Low Tolerance for low error...!
	// Initialize the matrices we need to do work on rotation
	Matrix3d J; // Inertia
	Matrix3d P; // Initialize skew-symmetric P
	P << 0, 0, 0,
	0, 0, 0,
	 0, 0, 0; // Currently no initial angular momentum.
	Matrix3d Q = Matrix3d::Identity(); // Rotation
	Matrix3d F;
	Matrix3d A;
	Matrix3d I = Matrix3d::Identity(); // Identity, for good measure
	Matrix3d E;
	// Initialize some vectors for the position work
	Vector3d x(0,0,0); // Initial position vector for body frame connection
	Vector3d p(0,0,0); // Initial momentum vector
	/* Initializations end here */


	thinkofthecustomer(fout,xout,n,m,tol);

	h = 60.0/n; // be careful. this has been changed.
	JDEF(J); // Function for defining the inertia matrix.

	/* Starts the timer */   
	init_hires_timer();
	hires_timer(&ts);
	// Solve the MV equation, decide new position.
	solver(F,P,J,Q,p,x,h,m,tol,n); // amazing. Future me is going to punch me in the head, I'm sure.

	cout << "Final Q:\n" << Q << endl;
	cout << "Final x:\n" << x << endl;
	E = (I-Q);
	error = E.norm();
   

	cout << endl << "Final Error: " << error << endl;
	hires_timer(&tf);
	cout << "Calculation time: " << tf - ts << " seconds." << endl;

	fout.close();
	xout.close();


	return 0;
}


// Solver function. Gives all of the new rotations, position, etc.
void solver(Matrix3d& F, Matrix3d& P, Matrix3d& J, Matrix3d& Q, Vector3d& p, Vector3d& x, double h, double m, double tol, int n)
{

    /* The for loop that solves world hunger */

	// Initialize the force vector for the superdraco booster at position 0
	Vector3d fsuperd0(0,0,140);
	// Initialize beta for the superdraco booster at position 0
	Vector3d bsuper0(1.85,0,.8659);
	// Initialize the torque vector for the superdraco booster at position 0
	Vector3d tsuper0(0,0,0);


	// Initialize the force vector for the superdraco booster at position pi/2
	Vector3d fsuperdpi2(0,0,0);
	// Initialize beta for the superdraco booster at position pi/2
	Vector3d bsuperpi2(0,-1.85,.8659);
	// Initialize the torque vector for the superdraco booster at position pi/2
	Vector3d tsuperpi2(0,0,0);

	// Initialize the force vector for the superdraco booster at position pi
	Vector3d fsuperdpi(0,0,140);
	// Initialize beta for the superdraco booster at position pi
	Vector3d bsuperpi(-1.85,0,.8659);
	// Initialize the torque vector for the superdraco booster at position pi
	Vector3d tsuperpi(0,0,0);
	// Initialize the force vector for the superdraco booster at position 3pi/2

	Vector3d fsuperd3pi2(0,0,0);
	// Initialize beta for the superdraco booster at position 3pi/2
	Vector3d bsuper3pi2(0,1.85,.8659);
	// Initialize the torque vector for the superdraco booster at position 3pi/2
	Vector3d tsuper3pi2(0,0,0);

	// Get the sum of the forces
	Vector3d fsum(0,0,0);
	fsum  = fsuperd0 + fsuperdpi2 + fsuperdpi + fsuperd3pi2;

	// Initialize the torque vector
	Vector3d t(0,0,0);
	// Initialize beta
//	Vector3d b(0,-1,0);	
	// Initialize torque matrix
	Matrix3d T;

    cout << "Solving Moser Veselov Equation...\n";
    for (int i=0; i<n; i++)
    {
	// This block gets the new torque at each time step.
	// Force is procedurally generated by changing the constant multiples.
//	Vector3d u(i*1000,i*2000,i*(-1000));
//	f = f+u;
	if (h*i > 8 && h*i < 12)
	{
		fsuperdpi << 0,0,140;
		fsuperd0 << 0,0,280;
	}
	if ( h*i >= 12 && h*i < 16 )
	{
		fsuperd0 << 0,0,0;
		fsuperdpi << 0,0,140;
	}
	if (h>= 16 && h < 20)
	{
		fsuperdpi << 0,0,140;
		fsuperd0 << 0,0,140;
	}
	if ( h >= 20)
	{
		fsuperdpi << 0,0,0;
		fsuperd0 << 0,0,0;
	}

	// Calculate each torque
	tsuper0 = bsuper0.cross(fsuperd0);
	tsuperpi2 = bsuperpi2.cross(fsuperdpi2);
	tsuperpi = bsuperpi.cross(fsuperdpi);
	tsuper3pi2 = bsuper3pi2.cross(fsuperd3pi2);
	t = tsuper0 + tsuperpi2 + tsuperpi + tsuper3pi2;
	T = so3IsomorphismInverse(t);
	
	F = MoserVeselov(P*h, J, 10, tol);
	P = (F.transpose())*P*F + h*T;
	Q = Q*F;

	p = p + h*Q*fsum;
        x = x + (h/m)*p;
	
	
        // Output the matrices to file
	fout << Q(0,0) << "," << Q(0,1) << "," << Q(0,2) << "," << endl;
	fout << Q(1,0) << "," << Q(1,1) << "," << Q(1,2) << "," << endl;
	fout << Q(2,0) << "," << Q(2,1) << "," << Q(2,2) << "," << endl;
        // Output position vectors to file
        xout << x(0) << "," << x(1) << "," << x(2) << endl;
    }

}




